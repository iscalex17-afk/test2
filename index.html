<script>
  // ===== Fundal tech: imagine + linii animate PCB + particule =====
  const canvas = document.getElementById('tech-bg');
  const ctx = canvas.getContext('2d', { alpha: true });
  let w, h, particles, t = 0;

  // imaginea chip pe fundal
  const chipImg = new Image();
  chipImg.src = 'assets/chip-bg.webp'; // <-- schimbă dacă ai alt nume/loc
  let imgReady = false;
  chipImg.onload = () => imgReady = true;

  function resize(){ 
    w = canvas.width = window.innerWidth; 
    h = canvas.height = window.innerHeight; 
    init(); 
  }

  function init(){
    particles = Array.from({length: Math.min(220, Math.floor(w*h/7000))}, () => ({
      x: Math.random()*w,
      y: Math.random()*h,
      vx: (Math.random()-0.5)*0.8,
      vy: (Math.random()-0.5)*0.8,
      r: Math.random()*1.8+0.6,
      tw: Math.random()*Math.PI*2
    }));
  }

  // trasee „PCB” care se mișcă (dash animat + paralax)
  function drawMovingPCBLines(time){
    const spacing = 80;
    const dash = [14, 18];
    const speed = 60; // viteza dungi (mai mare = mai rapid)
    const offset = (time * speed);

    ctx.save();
    ctx.lineWidth = 1.25;

    // strat 1 — înclinat ↘︎ (albastru)
    ctx.strokeStyle = 'rgba(56,189,248,0.55)';
    ctx.setLineDash(dash);
    ctx.globalAlpha = 0.28;
    for(let x = -w; x < w*2; x += spacing){
      ctx.lineDashOffset = -offset + x*0.1;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x - h, h);
      ctx.stroke();
    }

    // strat 2 — înclinat ↗︎ (verde), ușor mai lent (parallax)
    ctx.strokeStyle = 'rgba(16,185,129,0.45)';
    ctx.globalAlpha = 0.22;
    for(let x = -w; x < w*2; x += spacing){
      ctx.lineDashOffset = offset*0.7 + x*0.08;
      ctx.beginPath();
      ctx.moveTo(x, h);
      ctx.lineTo(x + h, 0);
      ctx.stroke();
    }

    // highlight care „curge” ca un flux de energie
    ctx.globalCompositeOperation = 'lighter';
    ctx.setLineDash([4, 22]);
    ctx.strokeStyle = 'rgba(99,102,241,0.35)';
    ctx.globalAlpha = 0.35;
    for(let x = -w; x < w*2; x += spacing*0.5){
      ctx.lineDashOffset = -offset*1.2;
      ctx.beginPath();
      ctx.moveTo(x, h);
      ctx.lineTo(x + h, 0);
      ctx.stroke();
    }
    ctx.restore();
    ctx.setLineDash([]);
    ctx.globalCompositeOperation = 'source-over';
  }

  function tick(){
    t += 0.005;
    ctx.clearRect(0,0,w,h);

    // 1) desenăm imaginea chip cu un mic pan/zoom subtil (să pară „vie”)
    if(imgReady){
      const cover = Math.max(w/chipImg.width, h/chipImg.height) * 1.08; // zoom mic
      const iw = chipImg.width * cover;
      const ih = chipImg.height * cover;
      const panX = Math.sin(t*0.6) * 18; // pan ușor
      const panY = Math.cos(t*0.5) * 14;
      const x = (w - iw)/2 + panX;
      const y = (h - ih)/2 + panY;

      ctx.globalAlpha = 0.55; // amestec cu UI
      ctx.drawImage(chipImg, x, y, iw, ih);
      ctx.globalAlpha = 1;
    }

    // 2) glow moale peste fundal
    const grad = ctx.createRadialGradient(
      w*0.2 + Math.sin(t)*50, h*0.15 + Math.cos(t*0.8)*40, 100,
      w*0.8 + Math.cos(t*0.6)*60, h*0.25 + Math.sin(t*0.9)*50, Math.max(w,h)
    );
    grad.addColorStop(0, 'rgba(59,130,246,0.08)');
    grad.addColorStop(1, 'rgba(2,6,23,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    // 3) linii „din poză” care curg constant
    drawMovingPCBLines(performance.now()/1000);

    // 4) particule + legături (păstrate din versiunea ta)
    ctx.fillStyle = 'rgba(148,163,184,0.7)';
    ctx.strokeStyle = 'rgba(99,102,241,0.12)';
    for(const p of particles){
      p.vx += Math.sin((p.y+t*40)/12000)*0.02;
      p.vy += Math.cos((p.x-t*40)/12000)*0.02;
      p.x += p.vx; p.y += p.vy;
      if(p.x<0||p.x>w) p.vx*=-1, p.x=Math.max(0, Math.min(w,p.x));
      if(p.y<0||p.y>h) p.vy*=-1, p.y=Math.max(0, Math.min(h,p.y));
      const r = p.r + Math.sin(p.tw + t*6)*0.3;
      ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(0.4,r),0,Math.PI*2); ctx.fill();
    }
    for(let i=0;i<particles.length;i++){
      for(let j=i+1;j<particles.length;j++){
        const a=particles[i], b=particles[j];
        const dx=a.x-b.x, dy=a.y-b.y, d=Math.hypot(dx,dy);
        if(d<120){
          ctx.globalAlpha = 1 - d/120;
          ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
          ctx.globalAlpha=1;
        }
      }
    }

    requestAnimationFrame(tick);
  }

  window.addEventListener('resize', resize);
  resize(); init(); tick();

  // ===== Coș simplu (localStorage) – rămâne neschimbat mai jos =====
  const CART_KEY = 'rivo_cart_v1';
  const cart = {
    items: [],
    load(){ try{ this.items = JSON.parse(localStorage.getItem(CART_KEY))||[] }catch(e){ this.items=[] } this.sync() },
    save(){ localStorage.setItem(CART_KEY, JSON.stringify(this.items)); this.sync() },
    sync(){ updateCartUI() },
    add(product){ const existing = this.items.find(i=>i.id===product.id); if(existing){ existing.qty += product.qty||1 } else { this.items.push({...product, qty: product.qty||1}) } this.save() },
    remove(id){ this.items = this.items.filter(i=>i.id!==id); this.save() },
    setQty(id, qty){ const item=this.items.find(i=>i.id===id); if(item){ item.qty=Math.max(1, qty); this.save() } },
    total(){ return this.items.reduce((s,i)=> s + i.price*i.qty, 0) }
  };
  function formatEUR(n){ return new Intl.NumberFormat('ro-RO',{style:'currency', currency:'EUR'}).format(n) }
  const product = { id:'prompts20', title:'20 Prompts pentru ChatGPT', price: 9.90, image:'', description:'Colecție PDF + TXT', download:'<ADAUGĂ_LINK_DOWNLOAD>' };
  document.addEventListener('DOMContentLoaded', ()=>{
    const addBtn = document.querySelector('[data-add-to-cart]');
    if(addBtn){ addBtn.addEventListener('click', ()=>{ cart.add({ id: product.id, title: product.title, price: product.price }); openCart(); }); }
  });
  const cartDrawer = document.getElementById('cartDrawer');
  const cartButton = document.getElementById('cartButton');
  const closeCartBtn = document.getElementById('closeCart');
  cartButton.addEventListener('click', openCart);
  closeCartBtn.addEventListener('click', closeCart);
  function openCart(){ cartDrawer.classList.remove('translate-x-full') }
  function closeCart(){ cartDrawer.classList.add('translate-x-full') }
  function updateCartUI(){
    document.getElementById('cartCount').textContent = cart.items.reduce((s,i)=>s+i.qty,0);
    const container = document.getElementById('cartItems');
    container.innerHTML = '';
    if(cart.items.length===0){ container.innerHTML = '<p class="text-slate-400">Coșul este gol.</p>'; }
    cart.items.forEach(i=>{
      const row = document.createElement('div');
      row.className = 'flex items-center justify-between gap-3 rounded-xl bg-white/5 p-3 border border-white/10';
      row.innerHTML = `
        <div>
          <div class="font-semibold">${i.title}</div>
          <div class="text-slate-400 text-xs">${formatEUR(i.price)}</div>
        </div>
        <div class="flex items-center gap-2">
          <button class="px-2 py-1 bg-white/10 rounded" data-dec>-</button>
          <input class="w-10 text-center bg-slate-900 border border-white/10 rounded" value="${i.qty}" aria-label="Cantitate" />
          <button class="px-2 py-1 bg-white/10 rounded" data-inc>+</button>
          <button class="ml-2 px-2 py-1 bg-red-500/80 hover:bg-red-500 rounded text-white" data-remove>×</button>
        </div>`;
      container.appendChild(row);
      const input = row.querySelector('input');
      row.querySelector('[data-inc]').onclick = ()=>{ cart.setQty(i.id, i.qty+1) };
      row.querySelector('[data-dec]').onclick = ()=>{ cart.setQty(i.id, i.qty-1) };
      row.querySelector('[data-remove]').onclick = ()=>{ cart.remove(i.id) };
      input.addEventListener('change', ()=>{ const v = parseInt(input.value||'1',10); cart.setQty(i.id, isNaN(v)?1:v) });
    });
    document.getElementById('cartTotal').textContent = formatEUR(cart.total());
    const checkoutList = document.getElementById('checkoutCart');
    if(checkoutList){
      checkoutList.innerHTML = cart.items.map(i=>`<div class='flex items-center justify-between'><span>${i.title} × ${i.qty}</span><span>${formatEUR(i.price*i.qty)}</span></div>`).join('') || '<p class="text-slate-400">Niciun produs în coș.</p>';
      document.getElementById('checkoutTotal').textContent = formatEUR(cart.total());
      const hidden = document.getElementById('cart_json');
      if(hidden){ hidden.value = JSON.stringify(cart.items); }
    }
  }
  cart.load();
  document.getElementById('gotoCheckout').addEventListener('click', ()=>{ closeCart(); setTimeout(()=>document.getElementById('checkout').scrollIntoView({behavior:'smooth'}), 50); });
  document.getElementById('year').textContent = new Date().getFullYear();
  document.getElementById('checkout-form').addEventListener('submit', ()=>{ document.getElementById('cart_json').value = JSON.stringify(cart.items); });

  // Swiper + fallback imagini (la fel ca înainte)
  window.addEventListener('load', ()=>{
    const sw = document.querySelector('.product-swiper');
    if(sw){ new Swiper(sw, { loop:true, pagination:{ el: sw.querySelector('.swiper-pagination'), clickable:true }, autoplay:{ delay:2500, disableOnInteraction:false } }); }
  });
  (function(){
    const PLACEHOLDER = "data:image/svg+xml;utf8,<?xml version='1.0'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 800'><defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop stop-color='%230F172A'/><stop offset='1' stop-color='%230A0F1F'/></linearGradient></defs><rect width='1200' height='800' fill='url(%23g)'/><g opacity='0.35' stroke='%235eead4'><circle cx='200' cy='200' r='120' fill='none'/><circle cx='1000' cy='600' r='160' fill='none'/><path d='M0 400 Q 300 300 600 400 T 1200 400' fill='none'/></g><text x='50%' y='52%' text-anchor='middle' font-family='Inter, Arial, sans-serif' font-size='72' fill='%2399f6e4' font-weight='700'>COMING SOON</text></svg>";
    function applyFallback(img){
      if(img.dataset.fallbackApplied) return;
      img.dataset.fallbackApplied='1';
      img.src = PLACEHOLDER;
      img.loading = 'lazy';
      img.style.objectFit='contain';
      img.style.background='rgba(255,255,255,0.04)';
      img.style.padding='24px';
      img.alt = (img.alt||'') + ' (coming soon)';
    }
    function watchImages(){
      document.querySelectorAll('img').forEach(img => {
        img.loading='lazy';
        img.addEventListener('error', ()=>applyFallback(img), { once:true });
        if(!img.getAttribute('src')) applyFallback(img);
      });
    }
    if(document.readyState === 'complete' || document.readyState === 'interactive') watchImages();
    else document.addEventListener('DOMContentLoaded', watchImages);
  })();
</script>
